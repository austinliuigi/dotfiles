" Name: vimrc
" Author: Austin Liu
" Date Created: July 2020
" Date Modified: April 8, 2022
"
""" Options {{{
" Boiler Plate {{{

syntax on                       " Enable syntax highlighting

filetype plugin indent on       " Enable filetype detection, execute filetype-specific ex commands local to the local buffer, and load the indent file for the detected filetype

set encoding=utf-8              " Character encoding format

set backspace=start,eol,indent  " Better backspace in insert mode

set showcmd

" }}}
" Preferences {{{

set clipboard^=unnamed          " Make system clipboard default

set hidden                      " Allow a buffer to load in a window that currently has a modified buffer

set relativenumber              " Make line numbers relative to current line

set number                      " Show line numbers (only shows current line # with relativenumber set)

set splitright                  " Default vert split window to appear on the right

set wildmenu                    " Command-line autocomplete bar

set wildcharm=<Tab>             " Set key for mappings to acticatte windmenu

set scrolloff=3                 " Set number of lines to keep above/below cursor

set tildeop                     " Tilde acts like an operator

set cursorline                  " Highlight line that cursor is on

set noshowmode                  " Don't show modemsg on cmdline

set showmatch                   " Show matching symmetric delimiter

set lazyredraw                  " Be conservative with screen refreshes

set belloff=esc                 " Don't ring bell when esc is pressed in normal-mode

set shortmess+=c                " Disable completion menu messages

set shortmess-=S                " Show search match index

set mouse=a                     " Allow use of mouse in all modes

set nowrap

set sidescroll=1

set sidescrolloff=3

" Cursor style in different modes
 "Ps = 0  -> blinking block.
 "Ps = 1  -> blinking block (default).
 "Ps = 2  -> steady block.
 "Ps = 3  -> blinking underline.
 "Ps = 4  -> steady underline.
 "Ps = 5  -> blinking bar (xterm).
 "Ps = 6  -> steady bar (xterm).
let &t_SI = "\e[5 q"
let &t_SR = "\e[4 q"
let &t_EI = "\e[1 q"
augroup cursorinit
    autocmd!
    autocmd VimEnter * if !has("gui_running") | silent execute '!echo -ne "\e[1 q"' | redraw! | endif
augroup END

" Don't ring bell for unmatched characters
augroup bell
    autocmd!
    autocmd FileType markdown,text setlocal belloff+=showmatch
augroup END

" Remove excess comment characters when joining lines
augroup fo
    autocmd!
    autocmd FileType * set formatoptions=tcjnqp
augroup END

" Set relative numbers for help windows
augroup relnumhelp
    autocmd!
    autocmd BufWinEnter * if &buftype == "help" | setlocal relativenumber | endif
augroup END

" }}}
" Color {{{

let g:gruvbox_transp_bg = 1        " make colorscheme bg transparent by default
let g:solarized_termtrans  =1

set termguicolors               " use gui colors in terminal; NOTE: must come before setting colorscheme

if &background ==# 'dark'
    colorscheme gruvbox8
else
    colorscheme github
endif

" Change iterm colorscheme to match vim colorscheme
augroup itermcolor
    autocmd!
    " autocmd Colorscheme * execute 'silent !echo -e "\033]50;SetProfile=<amatch>\a"'
    autocmd Colorscheme * if expand("<amatch>") ==# "gruvbox8" | execute 'silent !echo -e "\033]50;SetProfile=gruvbox\a"' | endif
    autocmd Colorscheme * if expand("<amatch>") ==# "github" | execute 'silent !echo -e "\033]50;SetProfile=github\a"' | endif
    autocmd Colorscheme * if expand("<amatch>") ==# "solarized8" | execute 'silent !echo -e "\033]50;SetProfile=solarized\a"' | endif
    " autocmd Colorscheme * echo expand("<amatch>") ==# "gruvbox8"
    " autocmd Colorscheme * echo g:colors_name ==# "gruvbox8"
    " autocmd Colorscheme * echo "<amatch>" ==# "gruvbox8"
augroup END

" Set vim terminal colors
" let g:terminal_ansi_colors = map(range(16), 0)
" let g:terminal_ansi_colors[0]  = "#282828"  " black
" let g:terminal_ansi_colors[1]  = "#CC241D"  " dark red
" let g:terminal_ansi_colors[2]  = "#98971C"  " dark green
" let g:terminal_ansi_colors[3]  = "#D79921"  " dark yellow
" let g:terminal_ansi_colors[4]  = "#458588"  " dark blue
" let g:terminal_ansi_colors[5]  = "#B16286"  " dark magenta
" let g:terminal_ansi_colors[6]  = "#689D6A"  " dark cyan
" let g:terminal_ansi_colors[7]  = "#A89984"  " light gray
" let g:terminal_ansi_colors[8]  = "#928374"  " dark gray
" let g:terminal_ansi_colors[9]  = "#FB4934"  " red
" let g:terminal_ansi_colors[10] = "#B8BB26"  " green
" let g:terminal_ansi_colors[11] = "#FABD2F"  " yellow
" let g:terminal_ansi_colors[12] = "#83A598"  " blue
" let g:terminal_ansi_colors[13] = "#D3869B"  " magenta
" let g:terminal_ansi_colors[14] = "#8EC07C"  " cyan
" let g:terminal_ansi_colors[15] = "#EBDBB2"  " white

hi! Terminal guibg=#282828 guifg=#EBDBB2

augroup termcolor
    autocmd!
    autocmd TerminalWinOpen * setlocal norelativenumber
augroup END

" Highlight todo everywhere (not just in comments)
augroup todo
    autocmd!
    autocmd Syntax * syn keyword myTodo TODO XXX containedin=ALL
    autocmd Syntax * hi link myTodo TODO
augroup END

" Resource all ftplugin stuff after changing colorschemes
augroup ftcolors
    autocmd!
    autocmd Colorscheme * let &filetype = &filetype
augroup END

" }}}
" Whitespace {{{

set tabstop=4                                       " Length of <tab> when it is displayed

set softtabstop=4                                   " Length of <tab> (& respective <bksp>) when you type it

set shiftwidth=4                                    " Indent length

set expandtab                                       " Tab will act as spaces (makes its length consistent across all platforms)

set autoindent                                      " Indent to the previous line's indent level

set smartindent                                     " Indent based on c syntax

set breakindent                                     " Make wrapped lines have same indentation as original line

set list                                            " Show whitespace characters

" set listchars=tab:▸\ ,eol:¬,precedes:‹,extends:›    " Set whitespace characters
set listchars=tab:▸\ ,eol:↴,precedes:‹,extends:›    " Set whitespace characters

set concealcursor=

let &showbreak = '↪ '
" set showbreak=⊂

" }}}
" Searching {{{

set incsearch                   " Search as you type

set hlsearch                    " Search highlighting

set ignorecase                  " Default to case insensitive

" }}}
" Completion {{{

" set spell
" augroup spell
"     autocmd!
"     autocmd VimEnter,ColorScheme * hi! SpellBad cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE guisp=NONE
"     autocmd VimEnter,ColorScheme * hi! SpellLocal cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE guisp=NONE
"     autocmd VimEnter,ColorScheme * hi! SpellRare cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE guisp=NONE
"     autocmd VimEnter,ColorScheme * hi! SpellCap cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE guisp=NONE
" augroup END

" set complete+=kspell

set completeopt=menuone,noinsert

set pumheight=5

" }}}
" Folding {{{

" Define folding using foldexpr option
set foldmethod=expr

" Use markers to fold in vimrc, inputrc, and txt files
augroup foldmarker
    autocmd!
    autocmd BufNewFile,BufReadPost,BufWritePost,SourcePost * if (expand("%:t") ==? "vimrc") || (expand("%:t") ==? "inputrc") || (expand("%:e") ==? "txt") | setlocal foldmethod=marker | endif
augroup END

" Set string that closed folds show
function! MyFoldText()
    let num_of_spaces = (v:foldlevel - 1) * 2
    let fold_start = repeat(' ', num_of_spaces)
    let line = getline(v:foldstart)
    let fold_title = substitute(line, '^\s\+\|"\ *\|//\|/\*\|\*/\|\ *{\+\d\=', '', 'g') . ' '
    let num_of_lines = v:foldend - v:foldstart
    let fold_linecount = '(' . num_of_lines . ' L)'
    let last_linenr_digits = strchars(line('$'))
    let fillcharcount = winwidth(0) - strchars(fold_title) - strchars(fold_start) - strchars(fold_linecount) - &numberwidth - ((last_linenr_digits >= &numberwidth) ? (last_linenr_digits - &numberwidth + 1) : 0) - 2
    " extra 2 for the signcolumn
    return fold_start . fold_title . repeat('·', fillcharcount) . fold_linecount
endfunction

set foldtext=MyFoldText()
set fillchars=fold:\ 

" }}}
" Timeout {{{

set notimeout ttimeout          " Wait indefinitely for a mapping, but a set time for key-codes

set ttimeoutlen=0               " Set time to wait for key-codes

" }}}
" GUI {{{

" Set gvim font & font size
if has("gui_running")
    if has("gui_gtk2")
        set guifont=Luxi\ Mono\ 12
    elseif has("x11")
    " Also for GTK 1
        set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
    elseif has("gui_win32")
        set guifont=Consolas:h11
    elseif has("gui_macvim")
         set guifont=Menlo:h12,DejaVu\ Sans\ Mono:h13
    endif
endif

set guioptions-=m               " Remove menu in gvim

set guioptions-=T               " Remove toolbar in gvim

set guioptions-=r               " Remove scrollbar in gvim

" }}}
" Backup Files {{{

let &directory=expand('~/.vimdata/Swap//')
if !isdirectory(&directory) | call mkdir(&directory, "p") | endif

set backup
let &backupdir=expand('~/.vimdata/Backup//')
if !isdirectory(&backupdir) | call mkdir(&backupdir, "p") | endif

set undofile
let &undodir=expand('~/.vimdata/Undo//')
if !isdirectory(&undodir) | call mkdir(&undodir, "p") | endif

" }}}
"}}}
""" Mappings{{{

let mapleader = " "

let maplocalleader = " "

nnoremap <leader> <nop>

" Motion mappings

nnoremap <expr> k v:count ? 'k' : 'gk'

nnoremap <expr> j v:count ? 'j' : 'gj'

" Register mappings

nnoremap <leader>c c

nnoremap <leader>C C

nnoremap <leader>d d

nnoremap <leader>D D

nnoremap <leader>s s

nnoremap <leader>S S

nnoremap <leader>x x

nnoremap <leader>X X

nnoremap c "_c

nnoremap C "_C

nnoremap d "_d

nnoremap D "_D

nnoremap s "_s

nnoremap S "_S

nnoremap x "_x

nnoremap X "_X

vnoremap <leader>c c

vnoremap <leader>C C

vnoremap <leader>d d

vnoremap <leader>D D

vnoremap <leader>s s

vnoremap <leader>S S

vnoremap <leader>x x

vnoremap <leader>X X

vnoremap c "_c

vnoremap C "_C

vnoremap d "_d

vnoremap D "_D

vnoremap s "_s

" vnoremap S "_S

vnoremap x "_x

vnoremap X "_X

" Static yank

" augroup StaticYank
"     autocmd!
"     autocmd VimEnter,CursorMoved * let s:pre_yank_pos = getpos('.')
"     autocmd TextYankPost * call StaticYank()
" augroup END

" function! StaticYank()
"     if v:event.operator == "y" && !empty(s:pre_yank_pos)
"         call setpos('.',s:pre_yank_pos)
"     endif
" endfunction

" Buffer list mappings

nnoremap <leader>]b :bn<CR>

nnoremap <leader>[b :bp<CR>

nnoremap <leader>\b :b#<CR>

nnoremap <leader><leader>b :ls<CR>:b<SPACE>

" Argument list mappings

nnoremap <leader>]a :n<CR>

nnoremap <leader>[a :N<CR>

nnoremap <leader><leader>a :args

" Window mappings

nmap <leader>oww <Plug>FzfNewBuffer

nnoremap <leader>nww :enew<CR>

nmap <leader>owh <Plug>FzfNewWinLeft

nmap <leader>owj <Plug>FzfNewWinDown

nmap <leader>owk <Plug>FzfNewWinUp

nmap <leader>owl <Plug>FzfNewWinRight

nmap <leader>nwh :topleft vnew<CR>

nmap <leader>nwj :botright new<CR>

nmap <leader>nwk :topleft new<CR>

nmap <leader>nwl :botright vnew<CR>

" Tab mappings

nnoremap <C-t><C-l> :tabn<CR>

nnoremap <C-t><C-h> :tabp<CR>

inoremap <C-t><C-l> <cmd>tabn<CR>

inoremap <C-t><C-h> <cmd>tabp<CR>

nnoremap <C-t>L :+tabmove<CR>

nnoremap <C-t>H :-tabmove<CR>

nnoremap <C-t>m :tabs<CR>:tabmove<SPACE>

nnoremap <leader><leader>t :tabs<CR>:tabn<SPACE>

nmap <leader>oth <Plug>FzfNewTabLeft

nmap <leader>otl <Plug>FzfNewTabRight

" Toggle mappings

nnoremap <leader>tc :HexokinaseToggle<CR>
" nnoremap <leader>tc :ToggleConcealLevel<CR>

nnoremap <leader>th :nohl<CR>

nnoremap <leader>tl :ToggleSpaceChar<CR>

nnoremap <leader>tn :set relativenumber!<CR>

nnoremap <leader>tw :set wrap!<CR>

" Normal mode mappings

nnoremap ! <cmd>so %<CR>

nnoremap <BS> <cmd>nohl<CR>

nnoremap <leader>E :Lexplore<CR>

nmap <leader>H <Plug>ToTopQuarter

nnoremap <leader><leader>l :set list!<CR>

nmap <leader>L <Plug>ToBottomQuarter

nnoremap <leader>p :put<CR>

nnoremap <leader>P :put!<CR>

nnoremap <C-t><C-t> <C-t>

nnoremap <expr> <leader>v empty(&virtualedit) ? ':set virtualedit+=all<CR>' : ':set virtualedit-=all<CR>'

nnoremap Y y$

nnoremap zC zCvzC

" Insert mode mappings

inoremap <C-r> <C-r><C-r>

inoremap <expr> <Left> pumvisible() ? "<C-e>" : "<Left>"

inoremap <expr> <Right> pumvisible() ? "<C-y>" : "<Right>"
" inoremap <expr> <Right> pumvisible() ? "<C-p><C-n><C-x><C-p>" : "<Right>"

imap <expr> <CR> pumvisible() ? "<C-e><Plug>(PearTreeExpand)" : "<Plug>(PearTreeExpand)"
" imap <expr> <CR> pumvisible() ? "<C-e><CR>" : "<CR>"

" Visual mode mappings

vnoremap < <gv

vnoremap > >gv

" Custom text objects

vnoremap <silent> az :<C-u>normal! [zV]z<CR>

omap <silent> az :normal Vaz<CR>

vnoremap <silent> iz :<C-u>normal! [zjV]zk<CR>

omap <silent> iz :normal Viz<CR>

vnoremap <silent> af :<C-u>normal! ggVG<CR>

omap <silent> af :normal Vaf<CR>

vnoremap <silent> if :<C-u>call MoveToLastNonBlankLine()\|call MoveToFirstNonBlankLine()\|normal! V``<CR>

omap <silent> if :normal Vif<CR>

vnoremap <silent> al :<C-u>normal! 0v$h<CR>

omap <silent> al :normal Val<CR>

vnoremap <silent> il :<C-u> normal! ^vg_<CR>

omap <silent> il :normal Vil<CR>

""" Mapping Functions{{{

function! TabRightIns()
    execute "normal! \<Esc>:tabn\<CR>"
    if col('.')!=1
        call feedkeys('a', 'n')
    else
        call feedkeys('i', 'n')
    endif
endfunction
command! TabRightIns call TabRightIns()

function! TabLeftIns()
    execute "normal! \<Esc>:tabp\<CR>"
    if col('.')!=1
        call feedkeys('a', 'n')
    else
        call feedkeys('i', 'n')
    endif
endfunction
command! TabLeftIns call TabLeftIns()

function! ToggleSpaceChar()
    if stridx(&listchars, "space") <= 0
        set listchars+=space:⋅
    else
        set listchars-=space:⋅
    endif
endfunction
command! ToggleSpaceChar call ToggleSpaceChar()

function! ToggleConcealLevel()
    if &l:conceallevel != 0
        setlocal conceallevel=0
    else
        setlocal conceallevel=2
    endif
endfunction
command! ToggleConcealLevel call ToggleConcealLevel()

function! MoveToFirstNonBlankLine()
    normal! gg
    if empty(substitute(getline(line('.')), '\s', '', "g"))
        call search('^\s*\S\+')
    endif
endfunction

function! MoveToLastNonBlankLine()
    normal! G
    if empty(substitute(getline(line('.')), '\s', '', "g"))
        call search('^\s*\S\+', 'b')
    endif
endfunction

"}}}

"}}}
""" Plugins {{{
" ale {{{

let g:ale_sign_priority = 10
let g:ale_sign_error = '>>'
let g:ale_sign_warning = '--'
augroup alehl
    autocmd!
    autocmd ColorScheme * highlight! link ALEErrorSign Error
    autocmd ColorScheme * highlight! link ALEWarningSign Todo
augroup END

packadd ale

" }}}
" AutoComplPop {{{

" let g:acp_enableAtStartup=0

packadd AutoComplPop

" }}}
" blank-line {{{

packadd blank-line

" nmap <leader>o <Plug>BlankLineBelow

" nmap <leader>O <Plug>BlankLineAbove

" nmap dD <Plug>ClearLineBlackHole

" nmap <leader>dD <Plug>ClearLineDefaultReg

" }}}
" Colorizer {{{

" let g:colorizer_auto_color = 1      " Turn on colorizer automatically for every file

let g:colorizer_auto_filetype='css,html,txt,md'       " Define filetypes in which colorizer will be turned on automatically

" }}}
" DynamicSigns {{{

let g:Signs_Alternate = 1

packadd DynamicSigns

" DisableSigns

" }}}
" fzf.vim {{{

packadd fzf
packadd fzf.vim
packadd fzf-open

" }}}
" indentLine {{{

" packadd indentLine

" }}}
" markdown-preview.nvim {{{

packadd markdown-preview.nvim

" }}}
" NetRW {{{

let g:netrw_dirhistmax=0

" if has("gui_running")
"     let g:netrw_home="~/vimfiles"
" else
"     let g:netrw_home="~/.vim"
" endif

let g:netrw_liststyle=3     " Tree-style listing

let g:netrw_bufsettings = "noma nomod nowrap ro nobl nu rnu"    " NetRW buffer settings

" }}}
" pear-tree {{{

packadd pear-tree

" }}}
" quick-scope {{{

let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

augroup qshl
    autocmd!
    autocmd ColorScheme * highlight! QuickScopePrimary guifg='#F39C12' gui=underline,bold ctermfg=155 cterm=underline,bold
    autocmd ColorScheme * highlight! QuickScopeSecondary guifg='#6F8EA3' gui=underline ctermfg=81 cterm=underline
augroup END

packadd quick-scope

" }}}
" rainbow {{{

let g:rainbow_active = 0

packadd rainbow

nnoremap ,r :RainbowToggle<CR>

" }}}
" self-diff {{{

packadd self-diff

nmap <leader><leader>do <Plug>DiffWithOpened

nmap <leader><leader>dls <Plug>DiffWithLastSave

" }}}
" staticyank.vim {{{

packadd staticyank.vim

" }}}
" traces.vim {{{

packadd traces.vim

" }}}
" ultisnips {{{

let g:UltiSnipsSnippetDirectories = [$HOME.'/.vim/snips']

let g:UltiSnipsExpandTrigger = '<Tab>'
let g:UltiSnipsJumpForwardTrigger = '<Tab>'
let g:UltiSnipsJumpBackwardTrigger = '<S-Tab>'

packadd ultisnips

" }}}
" vim-commentary {{{

packadd vim-commentary

" xmap ,c  <Plug>Commentary

" xmap <C-c>  <Plug>Commentary

" nmap ,c  <Plug>Commentary

" omap ,c  <Plug>Commentary

" nmap ,cc <Plug>CommentaryLine


" }}}
" vim-easy-align {{{

" 1. <Enter> key in visual mode, or `ga` followed by a motion or a text object to
"    start interactive mode
" 2. Optional: Enter keys to select alignment mode (left, right, or center)
" 3. Optional: N-th delimiter (default: 1)
"   - `1` Around the 1st occurrences of delimiters
"   - `2` Around the 2nd occurrences of delimiters
"   - ...
"   - `*` Around all occurrences of delimiters
"   - `**` Left-right alternating alignment around all delimiters
"   - `-` Around the last occurrences of delimiters (`-1`)
"   - `-2` Around the second to last occurrences of delimiters
"   - ...
" 4. Delimiter key (a single keystroke; <Space>, `=`, `:`, `.`, `|`, `&`, `#`, `,`)

packadd vim-easy-align

nmap ,a <Plug>LiveEasyAlign

vmap ,a <Plug>LiveEasyAlign

" }}}
" vim-eunuch {{{

let g:eunuch_no_maps=1

packadd vim-eunuch

" }}}
" vim-fugitive {{{

packadd vim-fugitive

" }}}
" vim-gitgutter {{{

let g:gitgutter_signs = 0

set updatetime=100

set signcolumn=yes

packadd vim-gitgutter

nnoremap <leader><leader>dg :GitGutterDiffOrig<CR>

nnoremap <leader>g :GitGutterLineHighlightsToggle<CR>

" }}}
" vim-highlightedyank {{{

" augroup yankhl
"     autocmd!
"     autocmd ColorScheme * highlight HighlightedyankRegion ctermbg=222 guibg=#F1E3B9
" augroup END

packadd vim-highlightedyank

" }}}
" vim-lumen {{{

augroup lumen
    autocmd!
    autocmd User LumenLight nested colorscheme github
    autocmd User LumenDark nested colorscheme gruvbox8
augroup END

packadd vim-lumen

" }}}
" vim-mundo {{{

" let g:mundo_width=75            " Set width of graph and preview (default 45)

" let g:mundo_preview_height=15   " Set height of preview window (default 15)

let g:mundo_preview_bottom=1    " Force preview window to be below windows instead of below graph

" let g:mundo_inline_undo=1       " Enable one line diff in graph

" let g:mundo_return_on_revert=0  " Keep focus in graph after selecting old undo state

packadd vim-mundo

nnoremap <leader>u :MundoToggle<CR>

" }}}
" vim-noh {{{

packadd vim-noh

" }}}
" vim-repeat {{{

packadd vim-repeat

" }}}
" vim-smoothie {{{

packadd vim-smoothie

" }}}
" vim-surround {{{

packadd vim-surround

" }}}
" vim-wordmotion {{{

let g:wordmotion_prefix = "<Space>" " Set prefix key for wordmotion mapping

packadd vim-wordmotion

" }}}
" vim-zoom {{{

packadd vim-zoom

nmap <C-w><C-m> <Plug>(zoom-toggle)

" }}}
" wsl-clip {{{

let g:disable_wsl_yank=has('gui_running')       " Disable wslyank for gui, enable for terminal

let g:disable_wsl_paste=has('gui_running')      " Disable wslpaste for gui, enable for terminal

" }}}
"}}}
""" Status Line {{{

set laststatus=2                                " always show status line

let g:currentmode = {
    \ 'n' : 'NORMAL',
    \ 'v' : 'VISUAL',
    \ 'V' : 'V-LINE',
    \ "\<C-v>" : 'V-BLOCK',
    \ 'i' : 'INSERT',
    \ 'R' : 'REPLACE',
    \ 's' : 'SELECT',
    \ 'S' : 'S-LINE',
    \ "\<C-s>" : 'S-BLOCK',
    \ 'c' : 'COMMAND',
    \ 't' : 'TERMINAL'
\ }

function! Getcurrentmode()
    return get(g:currentmode, mode())
endfunction


function! Getfiletype()
    let l:ftype = &filetype
    if strlen(ftype) ==? 0
        return '[NONE]'
    else
        return '[' . toupper(l:ftype) . ']'
    endif
endfunction


function! Getmodified()
    if &readonly
        return '[RO]'
    elseif &modified && (&buftype !=? "terminal")
        return '[+]'
    else
        return ''
    endif
endfunction


function! StatusLineGui()
    if win_getid(winnr()) ==? g:statusline_winid
        if mode() ==? 'n' || mode() ==? 'c'
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=109 ctermbg=231 gui=NONE guifg=#445588 guibg=#ececec 
            " statusline of active window in normal or command mode
            return '%#User1# %{Getfiletype()} %#User2# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'i' || mode() ==? 'r' 
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=178 ctermbg=231 gui=NONE guifg=#d7af00 guibg=#ececec 
            " statusline of active window in insert or replace modes
            return '%#User1# %{Getfiletype()} %#User3# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'v' || mode() ==? 's' || mode() ==? "\<C-v>" || mode() ==? "\<C-s>"
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=247 ctermbg=231 gui=NONE guifg=#9e9e9e guibg=#ececec 
            " statusline of active window in visual or select modes
            return '%#User1# %{Getfiletype()} %#User4# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 't'
            " " set statusline highlight group
            " hi! StatusLine cterm=NONE ctermfg=142 ctermbg=231 gui=NONE guifg=#afaf00 guibg=#ffffff 
            "
            " statusline of active window in terminal mode
            return '%#User1# %{Getfiletype()} %#User6# %{Getcurrentmode()} %* %f '
        endif
    else                                                                               
        " statusline of inactive windows
        return '%#User1# %{Getfiletype()} %#User7# %{Getcurrentmode()} %* %f %#User9#%{Getmodified()}%=%*LN:%4l  CN:%3c '
    endif
endfunction

function! StatusLineTerm()
    if win_getid(winnr()) ==? g:statusline_winid
        if mode() ==? 'n' || mode() ==? 'c'
            " statusline of active window in normal or command mode
            return '%#User1# %{Getfiletype()}%* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'i' || mode() ==? 'r' 
            " statusline of active window in insert or replace modes
            return '%#User1# %{Getfiletype()}%* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'v' || mode() ==? 's' || mode() ==? "\<C-v>" || mode() ==? "\<C-s>"
            " statusline of active window in visual or select modes
            return '%#User1# %{Getfiletype()}%* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 't'
            " statusline of active window in terminal mode
            return '%#User1# %{Getfiletype()}%* %f '
        endif
    else                                                                               
        " statusline of inactive windows
        return '%#User1# %{Getfiletype()}%* %f %#User9#%{Getmodified()}%=%*LN:%4l  CN:%3c '
    endif
endfunction

if has("gui_running")
    set statusline=%!StatusLineGui()
else
    set statusline=%!StatusLineTerm()
endif

"}}}
