" Name: vimrc
" Author: Austin Liu
" Date Created: July 2020
" Date Modified: January 30, 2022
"
""" Options {{{
" Boiler Plate {{{

syntax on                       " Enable syntax highlighting

filetype plugin indent on       " Enable filetype detection, execute filetype-specific ex commands local to the local buffer, and load the indent file for the detected filetype

set encoding=utf-8              " Character encoding format

set backspace=start,eol,indent  " Better backspace in insert mode

set showcmd

" }}}
" Preferences {{{

set clipboard^=unnamed

set hidden                      " Allow a buffer to load in a window that currently has a modified buffer

set relativenumber              " Make line numbers relative to current line

set number                      " Show line numbers (only shows current line # with relativenumber set)

set splitright                  " Default vert split window to appear on the right

set wildmenu                    " Command-line autocomplete bar

set scrolloff=3                 " Set number of lines to keep above/below cursor

set tildeop                     " Tilde acts like an operator

set cursorline                  " Highlight line that cursor is on

set noshowmode                  " Don't show modemsg on cmdline

set showmatch                   " Show matching symmetric delimiter

set lazyredraw                  " Be conservative with screen refreshes

set belloff=esc                 " Don't ring bell when esc is pressed in normal-mode

" Cursor style in different modes
 "Ps = 0  -> blinking block.
 "Ps = 1  -> blinking block (default).
 "Ps = 2  -> steady block.
 "Ps = 3  -> blinking underline.
 "Ps = 4  -> steady underline.
 "Ps = 5  -> blinking bar (xterm).
 "Ps = 6  -> steady bar (xterm).
let &t_SI = "\e[5 q"
let &t_SR = "\e[4 q"
let &t_EI = "\e[1 q"
augroup cursorinit
    autocmd!
    autocmd VimEnter * if !has("gui_running") | silent execute '!echo -ne "\e[1 q"' | redraw! | endif
augroup END

" Don't ring bell for unmatched characters
augroup bell
    autocmd!
    autocmd FileType markdown,text setlocal belloff+=showmatch
augroup END

" Remove excess comment characters when joining lines
augroup fo
    autocmd!
    autocmd FileType * set formatoptions=jn
augroup END

augroup h
    autocmd!
    autocmd BufWinEnter * if &buftype == "help" | setlocal relativenumber | endif
augroup END

" }}}
" Color {{{

" let g:scheme_termtrans=1        " make colorscheme bg transparent by default
let g:gruvbox_transp_bg=1        " make colorscheme bg transparent by default

if has("gui_running")
    colorscheme github
else
    colorscheme gruvbox8
endif

" Highlight todo everywhere (not just in comments)
augroup todo
    autocmd!
    autocmd Syntax * syn keyword myTodo TODO XXX containedin=ALL
    autocmd Syntax * hi link myTodo TODO
augroup END

" }}}
" Whitespace {{{

set tabstop=4                                       " Length of <tab> when it is displayed

set softtabstop=4                                   " Length of <tab> (& respective <bksp>) when you type it

set shiftwidth=4                                    " Indent length

set expandtab                                       " Tab will act as spaces (makes its length consistent across all platforms)

set autoindent                                      " Indent to the previous line's indent level

set smartindent                                     " Indent based on c syntax

set breakindent                                     " Make wrapped lines have same indentation as original line

set list                                            " Show whitespace characters

set listchars=tab:▸\ ,eol:¬,precedes:‹,extends:›    " Set whitespace characters

let &showbreak = '↪ '
" set showbreak=⊂

function! ToggleSpaceChar()
    if stridx(&listchars, "space") <= 0
        set listchars+=space:.
    else
        set listchars-=space:.
    endif
endfunction
command! ToggleSpaceChar call ToggleSpaceChar()

function! ToggleConcealLevel()
    if &l:conceallevel != 0
        setlocal conceallevel=0
    else
        setlocal conceallevel=2
    endif
endfunction
command! ToggleConcealLevel call ToggleConcealLevel()

" }}}
" Searching {{{

set incsearch                   " Search as you type

set hlsearch                    " Search highlighting

set ignorecase                  " Default to case insensitive

" }}}
" Folding {{{

" Define folding using foldexpr option
set foldmethod=expr

" Use markers to fold in vimrc, inputrc, and txt files
augroup foldmarker
    autocmd!
    autocmd BufNewFile,BufReadPost,BufWritePost * if (expand("%:t") ==? "vimrc") || (expand("%:t") ==? "inputrc") || (expand("%:e") ==? "txt") | setlocal foldmethod=marker | endif
augroup END

" Set string that closed folds show
function! MyFoldText()
    let num_of_spaces = (v:foldlevel - 1) * 2
    let fold_start = repeat(' ', num_of_spaces)
    let line = getline(v:foldstart)
    let fold_title = substitute(line, '^\s\+\|"\ *\|//\|/\*\|\*/\|\ *{\+\d\=', '', 'g') . ' '
    let num_of_lines = v:foldend - v:foldstart
    let fold_linecount = '(' . num_of_lines . ' L)'
    let last_linenr_digits = strchars(line('$'))
    let fillcharcount = winwidth(0) - strchars(fold_title) - strchars(fold_start) - strchars(fold_linecount) - &numberwidth - ((last_linenr_digits >= &numberwidth) ? (last_linenr_digits - &numberwidth + 1) : 0)
    return fold_start . fold_title . repeat('·', fillcharcount) . fold_linecount
endfunction

set foldtext=MyFoldText()
set fillchars=fold:\ 

" }}}
" Timeout {{{

set notimeout ttimeout          " Wait indefinitely for a mapping, but a set time for key-codes

set ttimeoutlen=0               " Set time to wait for key-codes

" }}}
" GUI {{{

" Set gvim font & font size
if has("gui_running")
    if has("gui_gtk2")
        set guifont=Luxi\ Mono\ 12
    elseif has("x11")
    " Also for GTK 1
        set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
    elseif has("gui_win32")
        set guifont=Consolas:h11
    elseif has("gui_macvim")
         set guifont=Menlo:h12,DejaVu\ Sans\ Mono:h13
    endif
endif

set guioptions-=m               " Remove menu in gvim

set guioptions-=T               " Remove toolbar in gvim

set guioptions-=r               " Remove scrollbar in gvim

" }}}
" Backup Files {{{

let &directory=expand('~/.vimdata/Swap//')
if !isdirectory(&directory) | call mkdir(&directory, "p") | endif

set backup
let &backupdir=expand('~/.vimdata/Backup//')
if !isdirectory(&backupdir) | call mkdir(&backupdir, "p") | endif

set undofile
let &undodir=expand('~/.vimdata/Undo//')
if !isdirectory(&undodir) | call mkdir(&undodir, "p") | endif

" }}}
"}}}
""" NetRW {{{

let g:netrw_dirhistmax=0

" if has("gui_running")
"     let g:netrw_home="~/vimfiles"
" else
"     let g:netrw_home="~/.vim"
" endif

let g:netrw_liststyle=3     " Tree-Style Listing

"}}}
""" Mundo {{{

" let g:mundo_width=75            " Set width of graph and preview (default 45)

" let g:mundo_preview_height=15   " Set height of preview window (default 15)

let g:mundo_preview_bottom=1    " Force preview window to be below windows instead of below graph

" let g:mundo_inline_undo=1       " Enable one line diff in graph

" let g:mundo_return_on_revert=0  " Keep focus in graph after selecting old undo state

"}}}
""" Wsl-Clip {{{

let g:disable_wsl_yank=has('gui_running')       " Disable wslyank for gui, enable for terminal

let g:disable_wsl_paste=has('gui_running')      " Disable wslpaste for gui, enable for terminal

"}}}
""" Status Line {{{

set laststatus=2                                " always show status line

let g:currentmode = {
    \ 'n' : 'NORMAL',
    \ 'v' : 'VISUAL',
    \ 'V' : 'V-LINE',
    \ "\<C-v>" : 'V-BLOCK',
    \ 'i' : 'INSERT',
    \ 'R' : 'REPLACE',
    \ 's' : 'SELECT',
    \ 'S' : 'S-LINE',
    \ "\<C-s>" : 'S-BLOCK',
    \ 'c' : 'COMMAND',
    \ 't' : 'TERMINAL'
\ }

function! Getcurrentmode()
    return get(g:currentmode, mode())
endfunction


function! Getfiletype()
    let l:ftype = &filetype
    if strlen(ftype) ==? 0
        return '[NONE]'
    else
        return '[' . toupper(l:ftype) . ']'
    endif
endfunction


function! Getmodified()
    if &readonly
        return '[RO]'
    elseif &modified && (&buftype !=? "terminal")
        return '[+]'
    else
        return ''
    endif
endfunction


function! StatusLine()
    if win_getid(winnr()) ==? g:statusline_winid
        if mode() ==? 'n' || mode() ==? 'c'
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=109 ctermbg=231 gui=NONE guifg=#87afaf guibg=#ececec 
            " statusline of active window in normal or command mode
            return '%#User1# %{Getfiletype()} %#User2# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'i' || mode() ==? 'r' 
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=178 ctermbg=231 gui=NONE guifg=#d7af00 guibg=#ececec 
            " statusline of active window in insert or replace modes
            return '%#User1# %{Getfiletype()} %#User3# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'v' || mode() ==? 's' || mode() ==? "\<C-v>" || mode() ==? "\<C-s>"
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=247 ctermbg=231 gui=NONE guifg=#9e9e9e guibg=#ececec 
            " statusline of active window in visual or select modes
            return '%#User1# %{Getfiletype()} %#User4# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 't'
            " " set statusline highlight group
            " hi! StatusLine cterm=NONE ctermfg=142 ctermbg=231 gui=NONE guifg=#afaf00 guibg=#ffffff 
            "
            " statusline of active window in terminal mode
            return '%#User1# %{Getfiletype()} %#User6# %{Getcurrentmode()} %* %f '
        endif
    else                                                                               
        " statusline of inactive windows
        return '%#User1# %{Getfiletype()} %#User7# %{Getcurrentmode()} %* %f %#User9#%{Getmodified()}%=%*LN:%4l  CN:%3c '
    endif
endfunction

set statusline=%!StatusLine()

"}}}
""" Mappings{{{

let mapleader = " "

" Alter default register mappings

nnoremap <leader>c c

nnoremap <leader>C C

nnoremap <leader>d d

nnoremap <leader>D D

nnoremap <leader>s s

nnoremap <leader>S S

nnoremap <leader>x x

nnoremap <leader>X X

nnoremap c "_c

nnoremap C "_C

nnoremap d "_d

nnoremap D "_D

nnoremap s "_s

nnoremap S "_S

nnoremap x "_x

nnoremap X "_X

vnoremap <leader>c c

vnoremap <leader>C C

vnoremap <leader>d d

vnoremap <leader>D D

vnoremap <leader>s s

vnoremap <leader>S S

vnoremap <leader>x x

vnoremap <leader>X X

vnoremap c "_c

vnoremap C "_C

vnoremap d "_d

vnoremap D "_D

vnoremap s "_s

vnoremap S "_S

vnoremap x "_x

vnoremap X "_X

" Leader mappings

nnoremap <leader>b :ls<CR>:b<SPACE>

nnoremap <leader><leader>c :ToggleConcealLevel<CR>

nmap <leader>dD <Plug>ClearLineDefaultReg

nnoremap <leader><leader>do :DiffOrig<CR>

nnoremap <leader><leader>dls :DiffLastSave<CR>

nnoremap <leader>e :e .<CR>

nnoremap <leader><leader>e :vsp .<CR><C-W>L

nnoremap <leader>h :nohl<CR>

nmap <leader>H <Plug>ToTopQuarter

nnoremap <leader>l :ToggleSpaceChar<CR>

nnoremap <leader><leader>l :set list!<CR>

nmap <leader>L <Plug>ToBottomQuarter

nnoremap <leader>n :set relativenumber!<CR>

nmap <leader>o <Plug>BlankLineBelow

nmap <leader>O <Plug>BlankLineAbove

nnoremap <leader>p :put<CR>

nnoremap <leader>P :put!<CR>

nnoremap <leader>u :MundoToggle<CR>

nnoremap <leader>w :set wrap!<CR>

" Non-leader mappings

nnoremap <space> <nop>

nmap dD <Plug>ClearLineBlackHole

nnoremap <expr> k v:count ? 'k' : 'gk'

nnoremap <expr> j v:count ? 'j' : 'gj'

nnoremap Y y$

nnoremap zC zCvzC

inoremap <C-R> <C-R><C-R>

vnoremap af :<C-U>normal! [zV]z<CR>

" Custom text objects

omap af :normal Vaf<CR>

vnoremap if :<C-U>normal! [zV]z<CR>

omap if :normal Vif<CR>

vnoremap aF :<C-U>normal! ggVG<CR>

omap aF :normal VaF<CR>

function! MoveToFirstNonBlankLine()
    normal! gg
    if empty(substitute(getline(line('.')), '\s', '', "g"))
        call search('^\s*\S\+')
    endif
endfunction

function! MoveToLastNonBlankLine()
    normal! G
    if empty(substitute(getline(line('.')), '\s', '', "g"))
        call search('^\s*\S\+', 'b')
    endif
endfunction

vnoremap iF :<C-U>call MoveToLastNonBlankLine()\|call MoveToFirstNonBlankLine()\|normal! V``<CR>

omap iF :normal ViF<CR>

"}}}
