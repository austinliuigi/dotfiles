" Name: vimrc
" Author: Austin Liu
" Date Created: July 2020
" Date Modified: August 5, 2020
"
""" Options {{{
" Boiler Plate {{{

syntax on                       " enable syntax highlighting

filetype plugin indent on       " enable filetype detection, execute filetype-specific ex commands local to the local buffer, and load the indent file for the detected filetype

set encoding=utf-8              " character encoding format

set backspace=start,eol,indent  " better backspace in insert mode

set showcmd

" }}}
" Whitespace {{{

set tabstop=4                   " length of <tab> when it is displayed

set softtabstop=4               " length of <tab> (& respective <bksp>) when you type it

set shiftwidth=4                " indent length

set expandtab                   " tab will act as spaces (makes its length consistent across all platforms)

set autoindent                  " indent to the previous line's indent level

set smartindent                 " indent based on c syntax

set list                        " show whitespace characters

set listchars=tab:▸\ ,eol:¬     " set whitespace characters

" }}}
" Searching {{{

set incsearch                   " search as you type

set hlsearch                    " search highlighting

set ignorecase                  " default to case insensitive

" }}}
" Folding {{{

set foldmethod=expr             " define folding using foldexpr option

augroup vimfold
autocmd!
" define folding in vim files using markers
autocmd BufReadPost *.vim,*/vimrc,*/.inputrc setlocal foldmethod=marker
augroup END

" }}}
" Timeout {{{

set notimeout ttimeout          " wait indefinitely for a mapping, but a set time for key-codes

set ttimeoutlen=0               " set time to wait for key-codes

" }}}
" Personal Preferences {{{

let g:scheme_termtrans=1        " make colorscheme bg transparent by default

colorscheme custom              " use personal colorscheme

set hidden                      " allow a buffer to load in a window that currently has a modified buffer

set relativenumber              " make line numbers relative to current line

set number                      " show line numbers (only shows current line # with relativenumber set)

set splitright                  " default vert split window to appear on the right

set wildmenu                    " command-line autocomplete bar

set scrolloff=3                 " set number of lines to keep above/below cursor

set tildeop                     " tilde acts like an operator

set cursorline                  " highlight line that cursor is on

set noshowmode                  " don't show modemsg on cmdline

set showmatch                   " show matching symmetric delimiter

set lazyredraw                  " be conservative with screen refreshes

set belloff=esc                 " don't ring bell when esc is pressed in normal-mode


" }}}
" GUI {{{

set guifont=Source_Code_Pro_Medium:h10:b,Fixedsys:h10:b   " set gvim font & font size

set guioptions-=m               " remove menu in gvim

set guioptions-=T               " remove toolbar in gvim

set guioptions-=r               " remove scrollbar in gvim

" }}}
" Backup Files {{{

let &directory=expand('~/.vimdata/Swap//')
if !isdirectory(&directory) | call mkdir(&directory, "p") | endif

set backup
let &backupdir=expand('~/.vimdata/Backup//')
if !isdirectory(&backupdir) | call mkdir(&backupdir, "p") | endif

set undofile
let &undodir=expand('~/.vimdata/Undo//')
if !isdirectory(&undodir) | call mkdir(&undodir, "p") | endif

" }}}
"}}}
""" NetRW {{{

let g:netrw_dirhistmax=0

if has("gui_running")
    let g:netrw_home="~/vimfiles"
else
    let g:netrw_home="~/.vim"
endif

let g:netrw_liststyle=3     " Tree-Style Listing

"}}}
""" Mundo {{{

" let g:mundo_width=75            " Set width of graph and preview (default 45)

" let g:mundo_preview_height=15   " Set height of preview window (default 15)

let g:mundo_preview_bottom=1    " Force preview window to be below windows instead of below graph

" let g:mundo_inline_undo=1       " Enable one line diff in graph

" let g:mundo_return_on_revert=0  " Keep focus in graph after selecting old undo state

"}}}
""" Diff {{{

" Diff current file with last saved state
function! DiffWithLastSave()
    let filetype=&ft
    diffthis
    leftabove vnew | read # | normal! ggdd
    exe "setlocal noswapfile readonly bufhidden=delete ft=" . filetype
    diffthis
    autocmd BufDelete <buffer> diffoff!
    " wincmd p
endfunction
command! DiffLastSave call DiffWithLastSave()

" Diff current file with state when opened
let b:changenr_on_load=0
augroup setchangenr
    autocmd!
    autocmd SourcePost,BufReadPost * let b:changenr_on_load=changenr()
augroup END
function! DiffWithOrig()
    let tmpfile=tempname()
    let curchange=changenr()
    exe 'undo ' . b:changenr_on_load
    exe 'w ' . tmpfile
    exe 'undo ' . curchange
    exe 'leftabove vertical diffsplit ' . tmpfile
    setlocal readonly bufhidden=delete
    autocmd BufDelete <buffer> diffoff!
endfunction
command! DiffOrig silent call DiffWithOrig()

"}}}
""" Status Line {{{

set laststatus=2                                " always show status line

let g:currentmode = {
    \ 'n' : 'NORMAL',
    \ 'v' : 'VISUAL',
    \ 'V' : 'V-LINE',
    \ "\<C-v>" : 'V-BLOCK',
    \ 'i' : 'INSERT',
    \ 'R' : 'REPLACE',
    \ 's' : 'SELECT',
    \ 'S' : 'S-LINE',
    \ "\<C-s>" : 'S-BLOCK',
    \ 'c' : 'COMMAND',
    \ 't' : 'TERMINAL'
\ }

function! Getcurrentmode()
    return get(g:currentmode, mode())
endfunction


function! Getfiletype()
    let l:ftype = &filetype
    if strlen(ftype) ==? 0
        return '[NONE]'
    else
        return '[' . toupper(l:ftype) . ']'
    endif
endfunction


function! Getmodified()
    if &modified
        return '[+]'
    else
        return ''
    endif
endfunction


function! StatusLine()
    if win_getid(winnr()) ==? g:statusline_winid
        if mode() ==? 'n' || mode() ==? 'c'
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=109 ctermbg=231 gui=NONE guifg=#87afaf guibg=#ffffff 
            " statusline of active window in normal or command mode
            return '%#User1# %{Getfiletype()} %#User2# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'i' || mode() ==? 'r' 
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=178 ctermbg=231 gui=NONE guifg=#d7af00 guibg=#ffffff 
            " statusline of active window in insert or replace modes
            return '%#User1# %{Getfiletype()} %#User3# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 'v' || mode() ==? 's' || mode() ==? "\<C-v>" || mode() ==? "\<C-s>"
            " set statusline highlight group
            hi! StatusLine cterm=NONE ctermfg=247 ctermbg=231 gui=NONE guifg=#9e9e9e guibg=#ffffff 
            " statusline of active window in visual or select modes
            return '%#User1# %{Getfiletype()} %#User4# %{Getcurrentmode()} %* %f %#User8#%{Getmodified()}%=%*LN:%4l  CN:%3c '
        elseif mode() ==? 't'
            " " set statusline highlight group
            " hi! StatusLine cterm=NONE ctermfg=142 ctermbg=231 gui=NONE guifg=#afaf00 guibg=#ffffff 
            "
            " statusline of active window in terminal mode
            return '%#User1# %{Getfiletype()} %#User6# %{Getcurrentmode()} %* %f '
        endif
    else                                                                               
        " statusline of inactive windows
        return '%#User1# %{Getfiletype()} %#User7# %{Getcurrentmode()} %* %f %#User9#%{Getmodified()}%=%*LN:%4l  CN:%3c '
    endif
endfunction

set statusline=%!StatusLine()

"}}}
""" Mappings{{{

let mapleader = " "

nnoremap <leader>c c

nnoremap <leader>C C

nnoremap <leader>d d

nnoremap <leader>D D

nnoremap <leader>e :vsp .<CR><C-W>L

nnoremap <leader>h :nohl<CR>

nnoremap <leader>l :set list!<CR>

nnoremap <leader>n :set relativenumber!<CR>

function! BlankLineBelow()
    execute 'normal!' . "o\<esc>0\"_D"
    call repeat#set("\<Plug>BlankLineBelow")
endfunction
nnoremap <Plug>BlankLineBelow :call BlankLineBelow()<CR>
nmap <leader>o <Plug>BlankLineBelow

function! BlankLineAbove()
    execute 'normal!' . "O\<esc>0\"_D"
    call repeat#set("O\<esc>0\"_D") " function doesn't get recalled
    " call repeat#set("\<leader>O") " interprets leader literally, try
    " \<lt>leader>O ?
endfunction
nnoremap <leader>O :call BlankLineAbove()<CR>
" :h b:changedtick

nnoremap <leader>u :MundoToggle<CR>

nnoremap <leader>w :set wrap!<CR>

nnoremap <leader>x x

nnoremap <leader><leader>do :DiffOrig<CR>

nnoremap <leader><leader>dls :DiffLastSave<CR>

nnoremap <space> <nop>

nnoremap c "_c

nnoremap C "_C

nnoremap d "_d

nnoremap dD 0D

nnoremap D "_D

nnoremap x "_x

nnoremap Y y$

inoremap <C-R> <C-R><C-R>

"}}}
